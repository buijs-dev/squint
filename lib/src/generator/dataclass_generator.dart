// Copyright (c) 2021 - 2022 Buijs Software
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

import "../analyzer/analyzer.dart";
import "../ast/ast.dart";
import "../common/common.dart";
import "generator.dart";

/// Convert a [CustomType] to a data class.
///
/// {@category generator}
extension CustomType2DataClass on CustomType {
  /// Add Annotation data to CustomType by generating the dataclass
  /// using [generateDataClassFile] and the using [analyze] to collect
  /// the annotations.
  ///
  /// {@category generator}
  CustomType get withDataClassMetadata {
    final dataclass = generateDataClassFile();
    final result = analyze(fileContent: dataclass);
    final customs = result.childrenCustomTypes;
    final enums = result.childrenEnumTypes;
    final members = <TypeMember>[];

    for (final member in result.parent!.members) {
      members.add(TypeMember(
        name: member.name,
        annotations: member.annotations,
        type: member.type.normalizeType(enums, customs),
      ));
    }

    return CustomType(
      className: result.parent!.className,
      members: members,
    );
  }

  /// Generate data class from [CustomType].
  ///
  /// {@category generator}
  String generateDataClassFile({
    SquintGeneratorOptions options = standardSquintGeneratorOptions,
  }) {

    final buffer = StringBuffer()..write("""
      |// Copyright (c) 2021 - 2022 Buijs Software
      |//
      |// Permission is hereby granted, free of charge, to any person obtaining a copy
      |// of this software and associated documentation files (the "Software"), to deal
      |// in the Software without restriction, including without limitation the rights
      |// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
      |// copies of the Software, and to permit persons to whom the Software is
      |// furnished to do so, subject to the following conditions:
      |//
      |// The above copyright notice and this permission notice shall be included in all
      |// copies or substantial portions of the Software.
      |//
      |// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
      |// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
      |// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
      |// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
      |// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
      |// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
      |// SOFTWARE.
      |
      |import 'package:squint_json/squint_json.dart';
      |""");

    final enums = members.map((e) => e.type).whereType<EnumType>().toSet();
    final customs = members.map((e) => e.type).whereType<CustomType>().toSet();

    if(options.includeCustomTypeImports && !options.generateChildClasses) {
      final types = <String>[];
      for (final element in enums) {
        types.add(element.className.snakeCase);
      }
      for (final element in customs) {
        types.add(element.className.snakeCase);
      }
      types.map((e) => "import '${e}_dataclass.dart';\n").forEach(buffer.write);
    }

    buffer.write("""
        /// Autogenerated data class by Squint.
        ${generateDataClassBody(options)}"""
    );

    /// If generateChildClasses is set to false
    /// then skip code generation for TypeMember CustomTypes/EnumTypes.
    if(options.generateChildClasses) {
      for (final ct in customs.toSet()) {
        buffer.write(ct.generateDataClassBody(options));
      }

      for (final et in enums.toSet()) {
        buffer.write(et.generateEnumClassBody(options));
      }
    }

    if(options.includeCustomTypeImports && !options.generateChildClasses) {

    }

    final toBeEncoded = members.where((element) {
      return element.type is CustomType || element.type is EnumType;
    }).map((element) {
      final name = element.name;
      final annotations = element.annotations;
      final type = element.type;
      if (type is CustomType) {
        return TypeMember(
          name: name,
          type: customs
              .firstWhere((element) => element.className == type.className),
          annotations: annotations,
        );
      }
      if (type is EnumType) {
        return TypeMember(
          name: name,
          type: enums
              .firstWhere((element) => element.className == type.className),
          annotations: annotations,
        );
      }

      throw SquintException("Unknown data type: $type");
    }).toList();

    for (final ct in toBeEncoded) {
      buffer
        ..write(ct.encodingMethodBody)
        ..write(ct.decodingMethodBody);
    }

    return buffer.toString().formattedDartCode;
  }

  /// Generate data class from [CustomType].
  ///
  /// {@category generator}
  String generateDataClassBody(SquintGeneratorOptions options) {
    // Sort members so required fields are serialized first and nullables last.
    final sortedMembers = members..sort((a, b) => !a.type.nullable ? -1 : 1);

    // Print the members as constructor fields.
    final constructorMembers =
        sortedMembers.map((e) => e.printConstructor).join("\n");

    // Print the members as class fields.
    final fieldMembers = sortedMembers.map((e) {
      return options.includeJsonAnnotations
          ? e.printField(alwaysAddJsonValue: options.alwaysAddJsonValue)
          : e.printFieldWithoutAnnotations;
    }).join(options.blankLineBetweenFields ? "\n\n" : "\n");

    return """
      |@squint
      |class $className {
      |   const $className ({
      |      $constructorMembers
      |   });
      |
      |   $fieldMembers
      |}
      |
      """
        .format;
  }
}

extension on TypeMember {
  String get printConstructor =>
      type.nullable ? "this.$name," : "required this.$name,";

  String get printFieldWithoutAnnotations => "final ${type.printType} $name;";

  String printField({bool alwaysAddJsonValue = false}) {
    final buffer = StringBuffer();

    if (type is CustomType) {
      buffer
        ..write("@JsonEncode(using: ${type.className.encodingMethodName})\n")
        ..write(
            "@JsonDecode<${type.className}, JsonObject>(using: ${type.className.decodingMethodName})\n");
    }

    if (type is EnumType) {
      buffer
        ..write("@JsonEncode(using: ${type.className.encodingMethodName})\n")
        ..write(
            "@JsonDecode<${type.className}, JsonString>(using: ${type.className.decodingMethodName})\n");
    }

    if (name != jsonNodeKey || alwaysAddJsonValue) {
      buffer.write('@JsonValue("$jsonNodeKey")\n');
    }

    buffer.write("final ${type.printType} $name;");
    return buffer.toString();
  }

  String get encodingMethodBody {
    if (type is CustomType) {
      return """
      JsonObject ${type.className.encodingMethodName}(${type.className} object) =>
        JsonObject.fromNodes(
        key: "$name",
        nodes: [
        ${(type as CustomType).members.toJsonNodeSetters(dataPrefix: "object.").join("\n")}
        ]);

        """;
    }

    return """
    JsonString ${type.className.encodingMethodName}(${type.className} object) {
        switch(object) {
          ${(type as EnumType).toJsonNodeSetters(name).join("\n")}
        }
      }
 
    """;
  }

  String get decodingMethodBody {
    if (type is CustomType) {
      return """
    ${type.className} ${type.className.decodingMethodName}(JsonObject object) =>
       ${type.className}(
        ${(type as CustomType).members.toJsonNodeGetters(dataPrefix: "object.").join("\n")}
        );

    """;
    }

    return """
    ${type.className} ${type.className.decodingMethodName}(JsonString value) {
      switch(value.data) {
          ${(type as EnumType).toJsonNodeGetters("object.").join("\n")}
      }
    }

    """;
  }
}

extension on String {
  String get decodingMethodName => "decode${camelCase()}";

  String get encodingMethodName => "encode${camelCase()}";
}

extension on AbstractType {
  AbstractType normalizeType(
    Set<EnumType> enumTypes,
    Set<CustomType> customTypes,
  ) {
    final customTypeOrNull =
        customTypes.firstBy((type) => type.className == className);
    if (customTypeOrNull != null) {
      return customTypeOrNull;
    }

    final enumTypeOrNull =
        enumTypes.firstBy((type) => type.className == className);
    if (enumTypeOrNull != null) {
      return enumTypeOrNull;
    }

    if (this is ListType) {
      final listType = this as ListType;
      final childType = listType.child.normalizeType(enumTypes, customTypes);
      return listType.nullable
          ? NullableListType(childType)
          : ListType(childType);
    }

    if (this is MapType) {
      final mapType = this as MapType;
      final keyType = mapType.key.normalizeType(enumTypes, customTypes);
      final valueType = mapType.value.normalizeType(enumTypes, customTypes);
      return mapType.nullable
          ? NullableMapType(key: keyType, value: valueType)
          : MapType(key: keyType, value: valueType);
    }

    return this;
  }
}
